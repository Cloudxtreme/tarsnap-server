package keyfile

import (
	"encoding/binary"
	"encoding/hex"
	"os"
	"text/template"

	"github.com/TheCreeper/tarsnap/tarsnap/tarcrypto"
)

const templateFile = `/* DO NOT EDIT!  This file is automatically generated. */

#include "bsdtar_platform.h"

#include <stdint.h>
#include <unistd.h>

#include "crypto.h"

#include "crypto_internal.h"

static size_t root_key_len = {{.Len}};

static uint8_t root_key[] = {
	{{.CArray}}};

/**
 * crypto_keys_server_import_root(void):
 * Import the public part of the server root key.
 */
int crypto_keys_server_import_root(void)
{
	return (crypto_keys_import(root_key, root_key_len, ~0));
}`

type KeyFile struct {
	Len  int
	Data []byte
}

func (k *KeyFile) CArray() (s string) {
	var length int
	var n = 1
	for _, v := range k.Data {
		if length == 8 {
			length = 0
			s += string('\n')
			s += "	"
		}
		length += 1

		s += "0x" + hex.EncodeToString([]byte{v})
		if n != k.Len {
			s += ", "
		}
		n += 1
	}
	return
}

/*
 * External key data format:
 * 4 byte little-endian integer = length of key data
 * 1 byte = key type
 * N bytes = key data, in key-specific format
 */
func GenerateSource(key []byte) (err error) {
	pub, _, err := tarcrypto.ParseKey(key)
	if err != nil {
		return
	}

	k := &KeyFile{}
	k.Data = append(k.Data, pub.N.Bytes()...)
	k.Data = append(k.Data, byte(pub.E))
	k.Len = len(k.Data)

	t, err := template.New("crypto_keys_server.c").Parse(templateFile)
	if err != nil {
		return
	}

	if err = t.Execute(os.Stdout, k); err != nil {
		return
	}
	return
}
